%precode {
import Grammar
import Data.Maybe
}

%operators "::" "|" "*" "+" "?" "=>"
%linecomments "#"
%blockcomments "#[" "]#"
%separateidentitycase
%parsermap { (languageDefsParser:) }

%token
      left          { TokenCustom (TokenDirective "left") }
      right         { TokenCustom (TokenDirective "right") }
      nonAssoc      { TokenCustom (TokenDirective "nonassoc") }
      prec          { TokenCustom (TokenDirective "prec") }
      token         { TokenCustom (TokenDirective "token") }
      export        { TokenCustom (TokenDirective "export") }
      precode       { TokenCustom (TokenDirective "precode") }
      operators     { TokenCustom (TokenDirective "operators") }
      keywords      { TokenCustom (TokenDirective "keywords") }
      lineComments  { TokenCustom (TokenDirective "linecomments") }
      blockComments { TokenCustom (TokenDirective "blockcomments") }
      separateIden  { TokenCustom (TokenDirective "separateidentitycase") }
      keepSpaces    { TokenCustom (TokenDirective "keepwhitespaces") }
      keepComments  { TokenCustom (TokenDirective "keepcomments") }
      parserMap     { TokenCustom (TokenDirective "parsermap") }
      empty         { TokenCustom (TokenDirective "empty") }
      codeBlock     { TokenCustom (TokenCodeBlock $$) } => { String }

FullDef :: Export? PreCode? ScannerDef* Grammar          { (v1, fromMaybe "" v2, v3, v4) }
                                                      => { (Maybe String, String, [(String, [String])], Grammar) }

Export :: export codeBlock                               { v2 }
                                                      => { String }

PreCode :: precode codeBlock                             { v2 }
                                                      => { String }

Grammar :: TokenDefs? PrecDef* Rule+                     { Grammar (fromMaybe [] v1) v2 v3 }
                                                      => { Grammar }

ScannerDef :: operators stringLit+                       { ("ops", v2) }
            | keywords stringLit+                        { ("kwds", v2) }
            | lineComments stringLit                     { ("line", [v2]) }
            | blockComments stringLit stringLit          { ("block", [v2, v3]) }
            | separateIden                               { ("sepiden", []) }
            | keepSpaces                                 { ("keepspace", []) }
            | keepComments                               { ("keepcmts", []) }
            | parserMap codeBlock                        { ("parser", [v2]) }
                                                      => { (String, [String]) }

TokenDefs :: token TokenMapping+                         { v2 }
                                                      => { [TokenDef] }

TypeDef :: '=>' codeBlock                                { v2 }
                                                      => { String }

TokenMapping :: identifier codeBlock TypeDef?            { TokenDef v1 v2 v3 }
              | stringLit codeBlock TypeDef?             { TokenDef v1 v2 v3 }
                                                      => { TokenDef }

PrecDef :: Prec Token+                                   { PrecLevel v1 v2 }
                                                      => { PrecLevel }

Token :: stringLit                                       { v1 }
       | identifier                                      { v1 }
                                                      => { String }

Prec :: left                                             { LeftAssoc }
      | right                                            { RightAssoc }
      | nonAssoc                                         { NonAssoc }
                                                      => { Associativity }

Rule :: upperIdentifier '::' RuleDef+('|') TypeDef?      { Rule v1 v3 v4 }
                                                      => { Rule }

RuleDef :: empty codeBlock                               { RuleProduction [] v2 Nothing }
         | RuleToken+ codeBlock                          { RuleProduction v1 v2 Nothing }
         | RuleToken+ prec stringLit codeBlock           { RuleProduction v1 v4 $ Just v3 }
         | RuleToken+ prec identifier codeBlock          { RuleProduction v1 v4 $ Just v3 }
                                                      => { RuleProduction }

RuleToken :: RuleTokenType                               { RuleToken v1 RuleTokenModifierNormal }
           | RuleTokenType '+' ModSeperator?             { RuleToken v1 $ RuleTokenModifierSome v3 }
           | RuleTokenType '*' ModSeperator?             { RuleToken v1 $ RuleTokenModifierMany v3 }
           | RuleTokenType '?'                           { RuleToken v1 RuleTokenModifierOptional }
                                                      => { RuleToken }

ModSeperator :: "(" RuleTokenType ")"                    { v2 }
                                                      => { RuleTokenType }

RuleTokenType :: upperIdentifier                         { RuleNonTerminal v1 }
               | stringLit                               { RuleTerminal v1 }
               | identifier                              { RuleTerminal v1 }
                                                      => { RuleTokenType }