%precode {
import Grammar
import Data.Maybe

wrapCustom :: TokenDef -> TokenDef
wrapCustom t = t{tokenPattern="TokenCustom (" ++ tokenPattern t ++ ")"}
}

%operators "::" "|" "*" "+" "?" "=>"
%linecomments "#"
%blockcomments "#[" "]#"
%separateidentitycase
%parsermap { (languageDefsParser:) } LanguageDefs

%customtoken
      left          { TokenDirective "left" }
      right         { TokenDirective "right" }
      nonAssoc      { TokenDirective "nonassoc" }
      prec          { TokenDirective "prec" }
      customtoken   { TokenDirective "customtoken" }
      export        { TokenDirective "export" }
      precode       { TokenDirective "precode" }
      operators     { TokenDirective "operators" }
      keywords      { TokenDirective "keywords" }
      lineComments  { TokenDirective "linecomments" }
      blockComments { TokenDirective "blockcomments" }
      separateIden  { TokenDirective "separateidentitycase" }
      keepSpaces    { TokenDirective "keepwhitespaces" }
      keepComments  { TokenDirective "keepcomments" }
      parserMap     { TokenDirective "parsermap" }
      empty         { TokenDirective "empty" }
      codeBlock     { TokenCodeBlock $$ } => String

FullDef :: Export? PreCode? ScannerDef* Grammar          { (v1, fromMaybe "" v2, v3, v4) }
                                                      => { (Maybe String, String, [(String, [String])], Grammar) }

CodeBlock :: codeBlock { v1 } | identifier { v1 } | upperIdentifier { v1 } => String

Export :: export codeBlock                               { v2 }
                                                      => String

PreCode :: precode codeBlock                             { v2 }
                                                      => { String }

Grammar :: TokenDefs? PrecDef* Rule+                     { Grammar (fmap wrapCustom $ fromMaybe [] v1) v2 v3 }
                                                      => Grammar

ScannerDef :: operators stringLit+                       { ("ops", v2) }
            | keywords stringLit+                        { ("kwds", v2) }
            | lineComments stringLit                     { ("line", [v2]) }
            | blockComments stringLit stringLit          { ("block", [v2, v3]) }
            | separateIden                               { ("sepiden", []) }
            | keepSpaces                                 { ("keepspace", []) }
            | keepComments                               { ("keepcmts", []) }
            | parserMap CodeBlock CodeBlock              { ("parser", [v2, v3]) }
                                                      => { (String, [String]) }

TokenDefs :: customtoken TokenMapping+                   { v2 }
                                                      => { [TokenDef] }

TypeDef :: '=>' CodeBlock                                { v2 }
                                                      => String

TokenMapping :: identifier codeBlock TypeDef?            { TokenDef v1 v2 v3 }
              | stringLit codeBlock TypeDef?             { TokenDef v1 v2 v3 }
                                                      => TokenDef

PrecDef :: Prec Token+                                   { PrecLevel v1 v2 }
                                                      => PrecLevel

Token :: stringLit                                       { v1 }
       | identifier                                      { v1 }
                                                      => String

Prec :: left                                             { LeftAssoc }
      | right                                            { RightAssoc }
      | nonAssoc                                         { NonAssoc }
                                                      => Associativity

Rule :: upperIdentifier '::' RuleDef+('|') TypeDef?      { Rule v1 v3 v4 }
                                                      => Rule

RuleDef :: empty codeBlock                               { RuleProduction [] v2 Nothing }
         | RuleToken+ codeBlock                          { RuleProduction v1 v2 Nothing }
         | RuleToken+ prec stringLit codeBlock           { RuleProduction v1 v4 $ Just v3 }
         | RuleToken+ prec identifier codeBlock          { RuleProduction v1 v4 $ Just v3 }
                                                      => RuleProduction

RuleToken :: RuleTokenType                               { RuleToken v1 RuleTokenModifierNormal }
           | RuleTokenType '+' ModSeperator?             { RuleToken v1 $ RuleTokenModifierSome v3 }
           | RuleTokenType '*' ModSeperator?             { RuleToken v1 $ RuleTokenModifierMany v3 }
           | RuleTokenType '?'                           { RuleToken v1 RuleTokenModifierOptional }
                                                      => RuleToken

ModSeperator :: "(" RuleTokenType ")"                    { v2 }
                                                      => RuleTokenType

RuleTokenType :: upperIdentifier                         { RuleNonTerminal v1 }
               | stringLit                               { RuleTerminal v1 }
               | identifier                              { RuleTerminal v1 }
                                                      => RuleTokenType